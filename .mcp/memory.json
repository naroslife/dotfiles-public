{"type":"entity","name":"Parallel Agent Orchestration Strategy","entityType":"Workflow Pattern","observations":["CRITICAL RULE: When orchestrating parallel agents, each agent MUST work in its own separate git worktree","Enforcement requirement: Agent prompts must include explicit working directory verification with pwd checks","Anti-pattern to avoid: Agents completing parallel work sequentially in main worktree","Lesson from 2025-01-13 session: Created worktrees ../headless-tui and ../headless-signal but agents didn't use them","Future requirement: Monitor that agents actually cd into their assigned worktrees before starting work","Integration strategy: Merge branches sequentially after each agent completes and passes tests","Benefits: True parallelization, conflict isolation, clean history, independent rollback capability","User prefers strict adherence to parallel orchestration patterns defined in Global CLAUDE.md","Violation detection: User actively monitors that agents follow worktree strategies","Enforcement context: This is not just a best practice but a CRITICAL requirement for this user"]}
{"type":"entity","name":"Code Quality Standards","entityType":"Development Practice","observations":["User enforces comprehensive error handling in shell scripts","Functions should be under 20-50 lines with single responsibility","Modules should be under 200 lines with clear domain separation","Test coverage should be >80% for critical paths","All code changes should be validated before committing"]}
{"type":"entity","name":"Nix Development Workflow","entityType":"Workflow Pattern","observations":["User structures Nix configs with modular architecture","Flake-based configurations preferred over legacy approaches","Dynamic user configuration generation for multi-user support","Platform-aware conditional loading (WSL, NVIDIA, etc.)","Validation with 'nix flake check' before applying changes"]}
{"type":"entity","name":"User Preferences","entityType":"Personal Preferences","observations":["IMPORTANT: This entity represents personal preferences across ALL machines and system usernames (uif58593, naroslife, enterpriseuser, etc.)","Working on headless SiL configuration generator project for automotive testing","Expects strict enforcement of parallel agent orchestration strategies","Requires agents working in parallel to use separate git worktrees, not the main worktree","Values proper isolation when orchestrating multiple agents for refactoring tasks","Caught that Agent A violated worktree strategy by working in main worktree instead of assigned ../headless-tui worktree during 2025-01-13 refactoring session","Emphasized: 'they have to work in separate worktrees next time' - indicating this is a critical requirement for future parallel work","Uses conventional commits format consistently across projects (feat:, fix:, docs:, refactor:, test:, chore:)","Values comprehensive documentation and expects it to be maintained alongside code","Prefers explicit over implicit code - clear names, obvious flow, direct dependencies","Expects tests to pass before committing changes","Runs quality checks before commits (nix flake check for Nix projects, test suites)","Prefers 2-space indentation for Nix, Shell, YAML, JSON; 4-space for Python","Uses Nix Home Manager for dotfiles management with flake-based configurations","Always verify CLI tool syntax by checking official documentation using Ref MCP (mcp__Ref__ref_search_documentation) or WebFetch before implementing","Don't assume CLI syntax - always validate with documentation first to avoid incorrect implementations"]}
{"type":"entity","name":"MCP Memory Best Practices","entityType":"Documentation","observations":["Always use generic entity names that are not tied to specific system usernames","User identity should be 'User Preferences' not username-specific entities","Preferences and patterns should be portable across machines and usernames","System-specific details (like usernames) should only appear in observations when contextually necessary","Entity names should represent concepts, not system identifiers"]}
{"type":"entity","name":"Claude Code CLI Commands","entityType":"documentation","observations":["The 'claude plugin install' command does NOT accept a --yes flag","The 'claude plugin marketplace add' command does NOT accept a --yes flag","Correct syntax: 'claude plugin install <plugin>' or 'claude plugin install <plugin>@<marketplace>'","Correct syntax: 'claude plugin marketplace add <source>'","Both commands are interactive by default and do not have non-interactive flags","For manual use in Claude Code: /plugin install <plugin>@<marketplace>","Example: /plugin install python-development@wshobson/agents","The wshobson/agents marketplace is the correct source for the 62 plugin collection","Plugin names remain the same across marketplaces, only the marketplace identifier changes"]}
{"type":"entity","name":"MCP Configuration Architecture","entityType":"Technical Implementation","observations":["Implemented two-tier MCP configuration: global (.mcp/global.json) and project-level (.mcp.json)","Global config at .mcp/global.json contains all non-Serena MCP servers: memory, sequential-thinking, fetch, Ref, filesystem, filesystem-with-morph, markitdown","Global config is symlinked from dotfiles to ~/.claude/.mcp.json by apply.sh script","Project-level .mcp.json contains ONLY Serena MCP server configuration with --project '.' flag","Project-level configs are NOT symlinked - each project has its own .mcp.json file","SessionStart hook automatically creates missing project .mcp.json files with correct Serena configuration","Claude Code reads both configs: global first, then project overlay - both sets of servers are active","Memory server uses ${HOME}/.claude/.mcp/memory.json path which is symlinked to dotfiles .mcp/memory.json","This architecture ensures global servers work across ALL projects while Serena is project-specific"]}
{"type":"entity","name":"Serena Configuration Management","entityType":"Technical Implementation","observations":["Serena global config uses minimal template approach - only web_dashboard_open_on_launch setting is version-controlled","Template stored at .serena/serena_config.yml contains only: web_dashboard_open_on_launch: false","Setup script (lib/setup/serena.sh) merges preference into existing config, does NOT replace entire file","If no config exists, script runs 'uvx serena --help' to trigger Serena to create default config, then applies preference","Projects list at bottom of serena_config.yml is managed by Serena and NOT version-controlled","Gitignore excludes .serena/ but keeps serena_config.yml template and project.yml","Each project has .serena/project.yml with language, ignored paths, and project-specific settings","Setup is idempotent - safe to run multiple times, preserves projects list","Graceful degradation if uvx not available - warns user to install and rerun"]}
{"type":"entity","name":"SessionStart Hook Implementation","entityType":"Automation Pattern","observations":["Claude Code SessionStart hook runs on startup and resume to manage project MCP configs","Hook checks if .mcp.json exists in current project directory","If missing, automatically creates .mcp.json with Serena configuration","Generated config includes: uvx, git+https://github.com/oraios/serena, start-mcp-server, --context ide-assistant, --project .","Provides user feedback about working directory and detected Serena project","Warns user to restart Claude Code after creating new .mcp.json","Hook implemented in .claude/settings.json under SessionStart with matcher 'startup|resume'","Uses heredoc to create JSON config file to avoid quote escaping issues","Detects project name from .serena/project.yml if it exists"]}
{"type":"entity","name":"Dotfiles MCP Integration Best Practices","entityType":"Best Practice","observations":["CRITICAL: Separate global MCP servers from project-specific ones to avoid conflicts","Global servers (memory, fetch, etc.) should be in .mcp/global.json symlinked to ~/.claude/.mcp.json","Project servers (Serena) should be in each project's .mcp.json, NOT symlinked","Never version-control system-specific data like Serena's projects list","Use minimal config templates that only contain customized settings","Implement setup scripts that merge preferences rather than replacing entire configs","Add SessionStart hooks to auto-generate missing project configs","Use proper gitignore patterns: exclude directories but keep templates","Make setup scripts idempotent for safe repeated execution","Provide graceful degradation when dependencies are missing"]}
{"type":"relation","from":"Code Quality Standards","to":"Parallel Agent Orchestration Strategy","relationType":"includes"}
{"type":"relation","from":"Nix Development Workflow","to":"Code Quality Standards","relationType":"implements"}
{"type":"relation","from":"User Preferences","to":"Parallel Agent Orchestration Strategy","relationType":"requires strict adherence to"}
{"type":"relation","from":"User Preferences","to":"Code Quality Standards","relationType":"enforces"}
{"type":"relation","from":"User Preferences","to":"Nix Development Workflow","relationType":"follows"}
{"type":"relation","from":"MCP Memory Best Practices","to":"User Preferences","relationType":"governs creation of"}
{"type":"relation","from":"User Preferences","to":"MCP Configuration Architecture","relationType":"requires implementation of"}
{"type":"relation","from":"User Preferences","to":"Serena Configuration Management","relationType":"requires implementation of"}
{"type":"relation","from":"MCP Configuration Architecture","to":"SessionStart Hook Implementation","relationType":"uses"}
{"type":"relation","from":"Serena Configuration Management","to":"SessionStart Hook Implementation","relationType":"uses"}
{"type":"relation","from":"Dotfiles MCP Integration Best Practices","to":"MCP Configuration Architecture","relationType":"guides design of"}
{"type":"relation","from":"Dotfiles MCP Integration Best Practices","to":"Serena Configuration Management","relationType":"guides design of"}