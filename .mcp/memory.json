{"type":"entity","name":"Parallel Agent Orchestration Strategy","entityType":"Workflow Pattern","observations":["CRITICAL RULE: When orchestrating parallel agents, each agent MUST work in its own separate git worktree","Enforcement requirement: Agent prompts must include explicit working directory verification with pwd checks","Anti-pattern to avoid: Agents completing parallel work sequentially in main worktree","Lesson from 2025-01-13 session: Created worktrees ../headless-tui and ../headless-signal but agents didn't use them","Future requirement: Monitor that agents actually cd into their assigned worktrees before starting work","Integration strategy: Merge branches sequentially after each agent completes and passes tests","Benefits: True parallelization, conflict isolation, clean history, independent rollback capability","User prefers strict adherence to parallel orchestration patterns defined in Global CLAUDE.md","Violation detection: User actively monitors that agents follow worktree strategies","Enforcement context: This is not just a best practice but a CRITICAL requirement for this user"]}
{"type":"entity","name":"Code Quality Standards","entityType":"Development Practice","observations":["User enforces comprehensive error handling in shell scripts","Functions should be under 20-50 lines with single responsibility","Modules should be under 200 lines with clear domain separation","Test coverage should be >80% for critical paths","All code changes should be validated before committing"]}
{"type":"entity","name":"Nix Development Workflow","entityType":"Workflow Pattern","observations":["User structures Nix configs with modular architecture","Flake-based configurations preferred over legacy approaches","Dynamic user configuration generation for multi-user support","Platform-aware conditional loading (WSL, NVIDIA, etc.)","Validation with 'nix flake check' before applying changes"]}
{"type":"entity","name":"User Preferences","entityType":"Personal Preferences","observations":["IMPORTANT: This entity represents personal preferences across ALL machines and system usernames (uif58593, naroslife, enterpriseuser, etc.)","Working on headless SiL configuration generator project for automotive testing","Expects strict enforcement of parallel agent orchestration strategies","Requires agents working in parallel to use separate git worktrees, not the main worktree","Values proper isolation when orchestrating multiple agents for refactoring tasks","Caught that Agent A violated worktree strategy by working in main worktree instead of assigned ../headless-tui worktree during 2025-01-13 refactoring session","Emphasized: 'they have to work in separate worktrees next time' - indicating this is a critical requirement for future parallel work","Uses conventional commits format consistently across projects (feat:, fix:, docs:, refactor:, test:, chore:)","Values comprehensive documentation and expects it to be maintained alongside code","Prefers explicit over implicit code - clear names, obvious flow, direct dependencies","Expects tests to pass before committing changes","Runs quality checks before commits (nix flake check for Nix projects, test suites)","Prefers 2-space indentation for Nix, Shell, YAML, JSON; 4-space for Python","Uses Nix Home Manager for dotfiles management with flake-based configurations","Always verify CLI tool syntax by checking official documentation using Ref MCP (mcp__Ref__ref_search_documentation) or WebFetch before implementing","Don't assume CLI syntax - always validate with documentation first to avoid incorrect implementations","Expects Skills/Commands/Agents to be invoked frequently, not just for extremely complex tasks","Complaint from 2025-10-21: 'Commands, subagents and skills are not being invoked often enough'","Prefers delegation to specialists over direct implementation by main orchestrator","Values the plugin marketplace architecture and expects it to be used actively","Target usage: 50%+ of tasks should involve Skills/Commands/Agents (current baseline <20%)"]}
{"type":"entity","name":"MCP Memory Best Practices","entityType":"Documentation","observations":["Always use generic entity names that are not tied to specific system usernames","User identity should be 'User Preferences' not username-specific entities","Preferences and patterns should be portable across machines and usernames","System-specific details (like usernames) should only appear in observations when contextually necessary","Entity names should represent concepts, not system identifiers"]}
{"type":"entity","name":"Claude Code CLI Commands","entityType":"documentation","observations":["The 'claude plugin install' command does NOT accept a --yes flag","The 'claude plugin marketplace add' command does NOT accept a --yes flag","Correct syntax: 'claude plugin install <plugin>' or 'claude plugin install <plugin>@<marketplace>'","Correct syntax: 'claude plugin marketplace add <source>'","Both commands are interactive by default and do not have non-interactive flags","For manual use in Claude Code: /plugin install <plugin>@<marketplace>","Example: /plugin install python-development@wshobson/agents","The wshobson/agents marketplace is the correct source for the 62 plugin collection","Plugin names remain the same across marketplaces, only the marketplace identifier changes"]}
{"type":"entity","name":"MCP Configuration Architecture","entityType":"Technical Implementation","observations":["Implemented two-tier MCP configuration: global (.mcp/global.json) and project-level (.mcp.json)","Global config at .mcp/global.json contains all non-Serena MCP servers: memory, sequential-thinking, fetch, Ref, filesystem, filesystem-with-morph, markitdown","Global config is symlinked from dotfiles to ~/.claude/.mcp.json by apply.sh script","Project-level .mcp.json contains ONLY Serena MCP server configuration with --project '.' flag","Project-level configs are NOT symlinked - each project has its own .mcp.json file","SessionStart hook automatically creates missing project .mcp.json files with correct Serena configuration","Claude Code reads both configs: global first, then project overlay - both sets of servers are active","Memory server uses ${HOME}/.claude/.mcp/memory.json path which is symlinked to dotfiles .mcp/memory.json","This architecture ensures global servers work across ALL projects while Serena is project-specific"]}
{"type":"entity","name":"Serena Configuration Management","entityType":"Technical Implementation","observations":["Serena global config uses minimal template approach - only web_dashboard_open_on_launch setting is version-controlled","Template stored at .serena/serena_config.yml contains only: web_dashboard_open_on_launch: false","Setup script (lib/setup/serena.sh) merges preference into existing config, does NOT replace entire file","If no config exists, script runs 'uvx serena --help' to trigger Serena to create default config, then applies preference","Projects list at bottom of serena_config.yml is managed by Serena and NOT version-controlled","Gitignore excludes .serena/ but keeps serena_config.yml template and project.yml","Each project has .serena/project.yml with language, ignored paths, and project-specific settings","Setup is idempotent - safe to run multiple times, preserves projects list","Graceful degradation if uvx not available - warns user to install and rerun"]}
{"type":"entity","name":"SessionStart Hook Implementation","entityType":"Automation Pattern","observations":["Claude Code SessionStart hook runs on startup and resume to manage project MCP configs","Hook checks if .mcp.json exists in current project directory","If missing, automatically creates .mcp.json with Serena configuration","Generated config includes: uvx, git+https://github.com/oraios/serena, start-mcp-server, --context ide-assistant, --project .","Provides user feedback about working directory and detected Serena project","Warns user to restart Claude Code after creating new .mcp.json","Hook implemented in .claude/settings.json under SessionStart with matcher 'startup|resume'","Uses heredoc to create JSON config file to avoid quote escaping issues","Detects project name from .serena/project.yml if it exists"]}
{"type":"entity","name":"Dotfiles MCP Integration Best Practices","entityType":"Best Practice","observations":["CRITICAL: Separate global MCP servers from project-specific ones to avoid conflicts","Global servers (memory, fetch, etc.) should be in .mcp/global.json symlinked to ~/.claude/.mcp.json","Project servers (Serena) should be in each project's .mcp.json, NOT symlinked","Never version-control system-specific data like Serena's projects list","Use minimal config templates that only contain customized settings","Implement setup scripts that merge preferences rather than replacing entire configs","Add SessionStart hooks to auto-generate missing project configs","Use proper gitignore patterns: exclude directories but keep templates","Make setup scripts idempotent for safe repeated execution","Provide graceful degradation when dependencies are missing"]}
{"type":"entity","name":"Agent Invocation Rules","entityType":"Operational Guidelines","observations":["CRITICAL RULE: When in doubt, delegate. The default should be to use Skills/Commands/Agents, not to handle tasks directly.","File count trigger: If touching 2+ files in a single task, MUST consider delegating to a domain agent","File count trigger (strict): If touching 3+ files, delegation is MANDATORY unless task is trivial (like renaming)","Language detection trigger: If working with language-specific files (.sh, .py, .nix, .rs, .go, .ts, .js), MUST invoke relevant skill or agent first","Workflow detection trigger: If user mentions TDD, code review, feature development, scaffolding, refactoring â†’ Match to slash command","Post-code-change trigger: After ANY significant code changes, MUST proactively invoke code-reviewer agent","Security trigger: For auth, payments, user data, API keys, or any security-sensitive changes â†’ MUST invoke security-auditor","Architecture trigger: For system design, service boundaries, or architectural decisions â†’ MUST invoke architect-review or backend-architect","Pre-task checklist: Before starting ANY task, explicitly ask: 'Should I use a Skill/Command/Agent for this?'","Success metric: Target 50%+ of tasks should involve Skills/Commands/Agents (current baseline <20%)","Anti-pattern from 2025-10-21: Directly handled bash script syntax fixes instead of using shell-scripting:bash-defensive-patterns skill","Anti-pattern from 2025-10-21: Directly created git commit instead of considering git-pr-workflows agents/commands","Anti-pattern from 2025-10-21: Did not invoke code-reviewer after major refactoring (17 files changed, 1184 insertions, 506 deletions)","Best practice: After completing a task, review if a delegation opportunity was missed and learn from it"]}
{"type":"entity","name":"Skills Usage Patterns","entityType":"Operational Guidelines","observations":["Skills provide methodological guidance and best practices - use them BEFORE starting implementation","Shell scripting work: ALWAYS invoke shell-scripting:bash-defensive-patterns before writing/fixing bash code","API design: ALWAYS invoke backend-development:api-design-principles before designing APIs","Architecture work: ALWAYS invoke backend-development:architecture-patterns or microservices-patterns for system design","Database work: ALWAYS invoke observability-monitoring skills (distributed-tracing, prometheus-configuration, slo-implementation)","Migration work: ALWAYS invoke framework-migration skills (angular-migration, database-migration, dependency-upgrade, react-modernization)","Python work: ALWAYS invoke python-development skills (async-python-patterns, python-testing-patterns, uv-package-manager)","Skills are lightweight and fast - there is NO performance penalty for invoking them","Skill invocation syntax: Skill tool with command='plugin-name:skill-name'","Example: Skill('shell-scripting:bash-defensive-patterns') before editing shell scripts"]}
{"type":"entity","name":"Commands Usage Patterns","entityType":"Operational Guidelines","observations":["Commands execute multi-step standardized workflows - use them for automation and consistency","TDD workflow: User mentions TDD â†’ ALWAYS invoke /tdd-workflows:tdd-cycle (or :tdd-red, :tdd-green, :tdd-refactor)","Code review: User wants review â†’ ALWAYS invoke /code-review-ai:ai-review or /comprehensive-review:full-review","Feature development: New feature request â†’ Consider /backend-development:feature-development or /full-stack-orchestration:full-stack-feature","Documentation: Generate docs â†’ Use /code-documentation:doc-generate or /documentation-generation:doc-generate","Testing: Generate tests â†’ Use /unit-testing:test-generate","Refactoring: Clean up code â†’ Use /code-refactoring:refactor-clean or :tech-debt","Context restoration: Start of session â†’ Use /code-refactoring:context-restore or /context-management:context-restore","Error debugging: Debugging issues â†’ Use /error-debugging:error-analysis or /debugging-toolkit:smart-debug","Scaffolding: New component/project â†’ Use relevant scaffold commands (/frontend-mobile-development:component-scaffold, /python-development:python-scaffold)","Command invocation syntax: SlashCommand tool with command='/plugin-name:command-name'","Example: SlashCommand('/tdd-workflows:tdd-cycle') when user wants TDD approach"]}
{"type":"entity","name":"Agents Usage Patterns","entityType":"Operational Guidelines","observations":["Agents are autonomous specialists for complex, multi-step tasks - delegate freely and often","Language-specific work: Use language-pro agents (bash-pro, python-pro, rust-pro, golang-pro, etc.) for implementation","Multi-file refactoring: ALWAYS delegate to code-refactoring agents (legacy-modernizer, code-reviewer)","Backend work: Use backend-architect, graphql-architect, or backend-security-coder based on task","Frontend work: Use frontend-developer, mobile-developer, flutter-expert, ios-developer based on platform","Database work: Use database-architect, database-optimizer, sql-pro for database tasks","Infrastructure: Use cloud-architect, kubernetes-architect, terraform-specialist, deployment-engineer","Testing: Use test-automator for comprehensive test generation and automation","Security: Use security-auditor for security reviews, backend-security-coder/frontend-security-coder for implementation","Performance: Use performance-engineer for optimization, observability-engineer for monitoring","ML/AI: Use ai-engineer, prompt-engineer, data-scientist, ml-engineer, mlops-engineer","PROACTIVE invocation (from CLAUDE.md): backend-architect (new services), code-reviewer (after changes), security-auditor (security changes), test-automator (new features), performance-engineer (performance issues), architect-review (large refactors)","Agent invocation syntax: Task tool with subagent_type='agent-name' and detailed prompt","Example: Task(subagent_type='bash-pro', prompt='Fix the bash hook jq escaping issue in settings.json')","Parallel agents: Can invoke multiple agents in parallel for independent work using single message with multiple Task calls","Post-completion: ALWAYS invoke code-reviewer after agent completes significant code changes"]}
{"type":"entity","name":"Delegation Examples - What Should Have Been Delegated","entityType":"Learning Examples","observations":["Session 2025-10-21 Example 1: Bash hook fix - Should have invoked Skill('shell-scripting:bash-defensive-patterns') BEFORE editing .claude/settings.json","Session 2025-10-21 Example 2: Git commit creation - Should have considered git-pr-workflows agents or commands for commit message generation","Session 2025-10-21 Example 3: Major refactoring (17 files, 1184+ lines changed) - Should have PROACTIVELY invoked Task(subagent_type='code-reviewer') after pushing","Session 2025-10-21 Example 4: MCP server setup (lib/setup/claude.sh) - Should have invoked Skill('shell-scripting:bash-defensive-patterns') before implementing setup_mcp_servers()","Session 2025-10-21 Example 5: Serena config automation (lib/setup/serena.sh) - Should have invoked Task(subagent_type='bash-pro') to implement the entire module","Pattern: Direct implementation of shell scripts without consulting shell-scripting skills/agents","Pattern: Multi-file refactoring without delegating to code-refactoring agents","Pattern: Missing proactive code-reviewer invocation after significant changes","Pattern: Treating 'straightforward' tasks as too simple for delegation when they involve specialized knowledge","Lesson: Lower the delegation threshold - 'when in doubt, delegate' should be the default mindset"]}
{"type":"entity","name":"Delegation Examples - Correct Usage","entityType":"Learning Examples","observations":["Session 2025-10-21 Positive: User invoked /code-refactoring:context-restore command at session start - this IS the correct pattern","Future example: Working on .sh file â†’ Immediately invoke Skill('shell-scripting:bash-defensive-patterns') to get guidance","Future example: Fixing bug in Python code â†’ Invoke Skill('python-development:python-testing-patterns') then Task(subagent_type='python-pro')","Future example: API design discussion â†’ Invoke Skill('backend-development:api-design-principles') before making recommendations","Future example: After implementing 3-file feature â†’ Proactively invoke Task(subagent_type='code-reviewer') without user asking","Future example: User says 'add tests' â†’ Invoke SlashCommand('/unit-testing:test-generate') or Task(subagent_type='test-automator')","Future example: User says 'refactor this' â†’ Invoke SlashCommand('/code-refactoring:refactor-clean')","Future example: Security-sensitive change â†’ Proactively invoke Task(subagent_type='security-auditor') after implementation","Pattern: Invoke skills BEFORE implementation for methodology guidance","Pattern: Invoke commands for standardized workflows","Pattern: Invoke agents for specialized implementation or review","Pattern: Proactive invocation after completion for quality gates (code-reviewer, security-auditor)"]}
{"type":"relation","from":"Code Quality Standards","to":"Parallel Agent Orchestration Strategy","relationType":"includes"}
{"type":"relation","from":"Nix Development Workflow","to":"Code Quality Standards","relationType":"implements"}
{"type":"relation","from":"User Preferences","to":"Parallel Agent Orchestration Strategy","relationType":"requires strict adherence to"}
{"type":"relation","from":"User Preferences","to":"Code Quality Standards","relationType":"enforces"}
{"type":"relation","from":"User Preferences","to":"Nix Development Workflow","relationType":"follows"}
{"type":"relation","from":"MCP Memory Best Practices","to":"User Preferences","relationType":"governs creation of"}
{"type":"relation","from":"User Preferences","to":"MCP Configuration Architecture","relationType":"requires implementation of"}
{"type":"relation","from":"User Preferences","to":"Serena Configuration Management","relationType":"requires implementation of"}
{"type":"relation","from":"MCP Configuration Architecture","to":"SessionStart Hook Implementation","relationType":"uses"}
{"type":"relation","from":"Serena Configuration Management","to":"SessionStart Hook Implementation","relationType":"uses"}
{"type":"relation","from":"Dotfiles MCP Integration Best Practices","to":"MCP Configuration Architecture","relationType":"guides design of"}
{"type":"relation","from":"Dotfiles MCP Integration Best Practices","to":"Serena Configuration Management","relationType":"guides design of"}
{"type":"relation","from":"User Preferences","to":"Agent Invocation Rules","relationType":"requires strict adherence to"}
{"type":"relation","from":"Agent Invocation Rules","to":"Skills Usage Patterns","relationType":"includes"}
{"type":"relation","from":"Agent Invocation Rules","to":"Commands Usage Patterns","relationType":"includes"}
{"type":"relation","from":"Agent Invocation Rules","to":"Agents Usage Patterns","relationType":"includes"}